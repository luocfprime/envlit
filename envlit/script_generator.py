"""
Shell script generation from configuration.
Generates bash scripts that can be sourced to load/unload environments.
"""

import os
import re
from typing import Any

from envlit.constants import SNAPSHOT_VAR_NAME
from envlit.operations import apply_operations, normalize_env_value, validate_operation


def generate_load_script(config: dict[str, Any], flag_overrides: dict[str, str] | None = None) -> str:  # noqa: C901
    """
    Generate a shell script to load an environment configuration.

    The generated script follows the sandwich pattern:
    1. envlit-internal-track begin (capture snapshot A)
    2. Pre-load hooks
    3. Environment variable exports
    4. Post-load hooks
    5. envlit-internal-track end (capture snapshot B, update state)
    Args:
        config: Configuration dictionary with env, flags, and hooks sections.
        flag_overrides: Optional dictionary of flag values to override defaults.

    Returns:
        Shell script as a string.
    """
    lines = ["#!/bin/bash", "# Generated by envlit", ""]

    # 1. Begin tracking - capture snapshot and export it
    lines.append("# Capture beginning state")
    lines.append(f"{SNAPSHOT_VAR_NAME}=$(envlit-internal-track begin)")
    lines.append(f"export {SNAPSHOT_VAR_NAME}")
    lines.append("")

    # 2. Pre-load hooks
    if "hooks" in config and "pre_load" in config["hooks"]:
        lines.append("# Pre-load hooks")
        for hook in config["hooks"]["pre_load"]:
            lines.append(f"# Hook: {hook['name']}")
            lines.append(hook["script"])
        lines.append("")

    # 3. Environment variable exports
    lines.append("# Environment variables")
    env_section = config.get("env", {})

    # Apply flag overrides first
    if flag_overrides:
        for flag_name, flag_value in flag_overrides.items():
            if "flags" in config and flag_name in config["flags"]:
                flag_config = config["flags"][flag_name]
                target_var = flag_config.get("target")
                if target_var:
                    # Check if there's a value mapping
                    if "map" in flag_config and flag_value in flag_config["map"]:
                        mapped_value = flag_config["map"][flag_value]
                        env_section[target_var] = mapped_value
                    else:
                        env_section[target_var] = flag_value

    for var_name, var_value in env_section.items():
        try:
            # Normalize value to list of operations
            operations = normalize_env_value(var_value)

            # Validate each operation
            for op in operations:
                validate_operation(op)

            # Get initial value from environment
            initial_value = os.environ.get(var_name)

            # Apply operations to get final value
            final_value = apply_operations(initial_value, operations)

            # Generate shell command based on final value
            if final_value is None:
                lines.append(f"unset {var_name}")
            else:
                escaped_value = escape_shell_value(final_value)
                lines.append(f'export {var_name}="{escaped_value}"')
        except ValueError as e:
            raise ValueError(f"Error processing variable '{var_name}': {e}") from e
    lines.append("")

    # 4. Post-load hooks
    if "hooks" in config and "post_load" in config["hooks"]:
        lines.append("# Post-load hooks")
        for hook in config["hooks"]["post_load"]:
            lines.append(f"# Hook: {hook['name']}")
            lines.append(hook["script"])
        lines.append("")

    # 5. End tracking - use temp file for Bash 3.2 compatibility (macOS default)
    lines.append("# Capture ending state and update state record")
    lines.append("__ENVLIT_TEMP=$(mktemp)")
    lines.append('envlit-internal-track end > "$__ENVLIT_TEMP"')
    lines.append('source "$__ENVLIT_TEMP"')
    lines.append('rm -f "$__ENVLIT_TEMP"')

    # 6. Clean up temporary snapshot
    lines.append("# Clean up temporary snapshot")
    lines.append(f"unset {SNAPSHOT_VAR_NAME}")

    return "\n".join(lines)


def generate_unload_script(config: dict[str, Any]) -> str:
    """
    Generate a shell script to unload an environment configuration.

    The script will:
    1. Run pre_unload hooks
    2. Call state restoration logic (handled by internal tracker)
    3. Run post_unload hooks

    Args:
        config: Configuration dictionary with hooks section.

    Returns:
        Shell script as a string.
    """
    lines = ["#!/bin/bash", "# Generated by envlit unload", ""]

    # 1. Pre-unload hooks
    if "hooks" in config and "pre_unload" in config["hooks"]:
        lines.append("# Pre-unload hooks")
        for hook in config["hooks"]["pre_unload"]:
            lines.append(f"# Hook: {hook['name']}")
            lines.append(hook["script"])
        lines.append("")

    # 2. Restore original state - use temp file for Bash 3.2 compatibility (macOS default)
    lines.append("# Restore original environment state")
    lines.append("__ENVLIT_TEMP=$(mktemp)")
    lines.append('envlit-internal-track restore > "$__ENVLIT_TEMP"')
    lines.append('source "$__ENVLIT_TEMP"')
    lines.append('rm -f "$__ENVLIT_TEMP"')
    lines.append("")

    # 3. Post-unload hooks
    if "hooks" in config and "post_unload" in config["hooks"]:
        lines.append("# Post-unload hooks")
        for hook in config["hooks"]["post_unload"]:
            lines.append(f"# Hook: {hook['name']}")
            lines.append(hook["script"])
        lines.append("")

    return "\n".join(lines)


def escape_shell_value(value: str) -> str:
    r"""
    Escape a value for use in a shell script, preserving ${VAR} references.

    We want to preserve ${VAR} and $VAR for shell expansion, including complex
    parameter expansions with modifiers like ${VAR:-default}, ${VAR:0:5}, etc.
    Since we use double quotes, we need to escape: $ ` " \ and newlines,
    EXCEPT for variable references and their modifiers.

    Supports {{DOLLAR}} placeholder for literal dollar signs.

    Args:
        value: The value to escape.

    Returns:
        Escaped value safe for use in double quotes.
    """
    # Strategy: Replace {{DOLLAR}} and ${VAR}/$VAR patterns with placeholders,
    # escape everything, then restore the patterns.

    # Step 1: Protect {{DOLLAR}} placeholder
    placeholders = {
        "{{DOLLAR}}": "$",  # For literal dollar sign
    }

    protected = {}
    counter = [0]
    temp_value = value

    for placeholder_pattern, char in placeholders.items():
        while placeholder_pattern in temp_value:
            marker = f"__ENVLIT_LITERAL_{counter[0]}__"
            protected[marker] = char
            temp_value = temp_value.replace(placeholder_pattern, marker, 1)
            counter[0] += 1

    # Step 2: Find and store all variable references
    var_refs = {}
    var_counter = [0]

    def replace_var(match):
        placeholder = f"__ENVLIT_VAR_{var_counter[0]}__"
        var_refs[placeholder] = match.group(0)
        var_counter[0] += 1
        return placeholder

    # Comprehensive pattern to match all variable forms in one pass
    # 1. Simple $var
    # 2. ${var} with optional modifiers (e.g., ${var:-default}, ${var:0:5}, ${var/old/new})
    # 3. ${#var} (length operator) and other special operators
    VAR_PATTERN = re.compile(
        r"\$([a-zA-Z_][a-zA-Z0-9_]*)"  # Simple $var
        r"|\${#?([a-zA-Z_][a-zA-Z0-9_]*)(?::?[^}]*)?}"  # ${var} or ${#var} with modifiers
    )
    temp_value = VAR_PATTERN.sub(replace_var, temp_value)

    # Step 3: Escape special characters for double quotes
    # In double quotes, need to escape: \ $ ` " and newline
    temp_value = temp_value.replace("\\", "\\\\")  # Backslash
    temp_value = temp_value.replace("$", "\\$")  # Dollar (for any remaining $)
    temp_value = temp_value.replace("`", "\\`")  # Backtick
    temp_value = temp_value.replace('"', '\\"')  # Double quote
    temp_value = temp_value.replace("\n", "\\n")  # Newline

    # Step 4: Restore variable references (without escaping)
    for placeholder, original in var_refs.items():
        temp_value = temp_value.replace(placeholder, original)

    # Step 5: Restore literal characters (escaped for shell)
    for marker, char in protected.items():
        if char == "$":
            temp_value = temp_value.replace(marker, "\\$")

    return temp_value
