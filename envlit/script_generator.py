"""
Shell script generation from configuration.
Generates bash scripts that can be sourced to load/unload environments.
"""

import os
import re
from typing import Any

from envlit.constants import SNAPSHOT_VAR_NAME
from envlit.path_ops import apply_path_operations


def generate_load_script(config: dict[str, Any], flag_overrides: dict[str, str] | None = None) -> str:  # noqa: C901
    """
    Generate a shell script to load an environment configuration.

    The generated script follows the sandwich pattern:
    1. _envlit_internal_track begin (capture snapshot A)
    2. Pre-load hooks
    3. Environment variable exports
    4. Post-load hooks
    5. _envlit_internal_track end (capture snapshot B, update state)

    Args:
        config: Configuration dictionary with env, flags, and hooks sections.
        flag_overrides: Optional dictionary of flag values to override defaults.

    Returns:
        Shell script as a string.
    """
    lines = ["#!/bin/bash", "# Generated by envlit", ""]

    # 1. Begin tracking - capture snapshot and export it
    lines.append("# Capture beginning state")
    lines.append(f"{SNAPSHOT_VAR_NAME}=$(envlit-internal-track begin)")
    lines.append(f"export {SNAPSHOT_VAR_NAME}")
    lines.append("")

    # 2. Pre-load hooks
    if "hooks" in config and "pre_load" in config["hooks"]:
        lines.append("# Pre-load hooks")
        for hook in config["hooks"]["pre_load"]:
            lines.append(f"# Hook: {hook['name']}")
            lines.append(hook["script"])
        lines.append("")

    # 3. Environment variable exports
    lines.append("# Environment variables")
    env_section = config.get("env", {})

    # Apply flag overrides first
    if flag_overrides:
        for flag_name, flag_value in flag_overrides.items():
            if "flags" in config and flag_name in config["flags"]:
                flag_config = config["flags"][flag_name]
                target_var = flag_config.get("target")
                if target_var:
                    # Check if there's a value mapping
                    if "map" in flag_config and flag_value in flag_config["map"]:
                        mapped_value = flag_config["map"][flag_value]
                        env_section[target_var] = mapped_value
                    else:
                        env_section[target_var] = flag_value

    for var_name, var_value in env_section.items():
        if var_value is None:
            # null means unset the variable
            lines.append(f"unset {var_name}")
        elif isinstance(var_value, list):
            # List means PATH operations
            lines.append(f"# Apply PATH operations to {var_name}")
            # Generate shell code to apply operations
            # For now, we'll use a simple approach - the operations will be applied
            # by reading current $VAR value, applying ops, and exporting
            script_lines = _generate_path_operation_script(var_name, var_value)
            lines.extend(script_lines)
        else:
            # Simple string value - preserve ${VAR} references for shell expansion
            escaped_value = escape_shell_value(str(var_value))
            lines.append(f'export {var_name}="{escaped_value}"')
    lines.append("")

    # 4. Post-load hooks
    if "hooks" in config and "post_load" in config["hooks"]:
        lines.append("# Post-load hooks")
        for hook in config["hooks"]["post_load"]:
            lines.append(f"# Hook: {hook['name']}")
            lines.append(hook["script"])
        lines.append("")

    # 5. End tracking - use source <() to execute the state update commands
    lines.append("# Capture ending state and update state record")
    lines.append("source <(envlit-internal-track end)")
    lines.append("")

    # 6. Clean up temporary snapshot
    lines.append("# Clean up temporary snapshot")
    lines.append(f"unset {SNAPSHOT_VAR_NAME}")

    return "\n".join(lines)


def generate_unload_script(config: dict[str, Any]) -> str:
    """
    Generate a shell script to unload an environment configuration.

    The script will:
    1. Run pre_unload hooks
    2. Call state restoration logic (handled by internal tracker)
    3. Run post_unload hooks

    Args:
        config: Configuration dictionary with hooks section.

    Returns:
        Shell script as a string.
    """
    lines = ["#!/bin/bash", "# Generated by envlit unload", ""]

    # 1. Pre-unload hooks
    if "hooks" in config and "pre_unload" in config["hooks"]:
        lines.append("# Pre-unload hooks")
        for hook in config["hooks"]["pre_unload"]:
            lines.append(f"# Hook: {hook['name']}")
            lines.append(hook["script"])
        lines.append("")

    # 2. Restore original state - use source <() to execute the restore commands
    lines.append("# Restore original environment state")
    lines.append("source <(envlit-internal-track restore)")
    lines.append("")

    # 3. Post-unload hooks
    if "hooks" in config and "post_unload" in config["hooks"]:
        lines.append("# Post-unload hooks")
        for hook in config["hooks"]["post_unload"]:
            lines.append(f"# Hook: {hook['name']}")
            lines.append(hook["script"])
        lines.append("")

    return "\n".join(lines)


def escape_shell_value(value: str) -> str:
    r"""
    Escape a value for use in a shell script, preserving ${VAR} references.

    We want to preserve ${VAR} and $VAR for shell expansion, including complex
    parameter expansions with modifiers like ${VAR:-default}, ${VAR:0:5}, etc.
    Since we use double quotes, we need to escape: $ ` " \ and newlines,
    EXCEPT for variable references and their modifiers.

    Args:
        value: The value to escape.

    Returns:
        Escaped value safe for use in double quotes.
    """
    # Strategy: Replace ${VAR} and $VAR patterns with placeholders,
    # escape everything, then restore the patterns.

    # Step 1: Find and store all variable references
    var_refs = {}
    counter = [0]

    def replace_var(match):
        placeholder = f"__ENVLIT_VAR_{counter[0]}__"
        var_refs[placeholder] = match.group(0)
        counter[0] += 1
        return placeholder

    # Comprehensive pattern to match all variable forms in one pass
    # 1. Simple $var
    # 2. ${var} with optional modifiers (e.g., ${var:-default}, ${var:0:5}, ${var/old/new})
    # 3. ${#var} (length operator) and other special operators
    VAR_PATTERN = re.compile(
        r"\$([a-zA-Z_][a-zA-Z0-9_]*)"  # Simple $var
        r"|\${#?([a-zA-Z_][a-zA-Z0-9_]*)(?::?[^}]*)?}"  # ${var} or ${#var} with modifiers
    )
    temp_value = VAR_PATTERN.sub(replace_var, value)

    # Step 2: Escape special characters for double quotes
    # In double quotes, need to escape: \ $ ` " and newline
    temp_value = temp_value.replace("\\", "\\\\")  # Backslash
    temp_value = temp_value.replace("$", "\\$")  # Dollar (for any remaining $)
    temp_value = temp_value.replace("`", "\\`")  # Backtick
    temp_value = temp_value.replace('"', '\\"')  # Double quote
    temp_value = temp_value.replace("\n", "\\n")  # Newline

    # Step 3: Restore variable references (without escaping)
    for placeholder, original in var_refs.items():
        temp_value = temp_value.replace(placeholder, original)

    return temp_value


def _generate_path_operation_script(var_name: str, operations: list[dict[str, str]]) -> list[str]:
    r"""
    Generate shell script lines to apply PATH-like operations to a variable.

    Uses the apply_path_operations() function from path_ops.py to compute
    the final value at generation time, then generates a single export command.

    Args:
        var_name: Name of the environment variable (e.g., "PATH").
        operations: List of operation dictionaries.

    Returns:
        List of shell script lines.
    """
    # Get current value of the variable at generation time
    current_value = os.environ.get(var_name, None)

    # Apply all operations using the tested path_ops module
    result = apply_path_operations(current_value, operations)

    # Escape the result for shell and generate single export
    escaped_result = escape_shell_value(result)

    return [f'export {var_name}="{escaped_result}"']
